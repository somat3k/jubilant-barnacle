"""
backtest_engine.py — Offline backtesting engine built on top of the
``backtesting`` library (https://kernc.github.io/backtesting.py/).

Supports:
  - Long/short signals generated by strategy_params (AI or Decision-Tree)
  - SMA crossover as the default fallback signal
  - ONNX model signal integration (optional field in strategy_params)
"""

from __future__ import annotations

import logging
from typing import Any

import numpy as np
import pandas as pd

logger = logging.getLogger(__name__)

# ---------------------------------------------------------------------------
# Backtesting.py Strategy classes
# ---------------------------------------------------------------------------

try:
    from backtesting import Backtest, Strategy
    from backtesting.lib import crossover

    _BT_AVAILABLE = True
except ImportError:
    _BT_AVAILABLE = False
    logger.warning(
        "backtesting library not installed — BacktestEngine will return dummy stats."
    )


def _sma(series: "pd.Series", period: int) -> "np.ndarray":
    return pd.Series(series).rolling(period).mean().to_numpy()


class _AIDecisionTreeStrategy:
    """Internal backtesting.py Strategy wired to external signal params."""

    # Class-level config injected before Backtest.run()
    _params: dict[str, Any] = {}

    def init(self):
        fast = int(self._params.get("fast_period", 10))
        slow = int(self._params.get("slow_period", 30))
        self._fast_ma = self.I(_sma, self.data.Close, fast)
        self._slow_ma = self.I(_sma, self.data.Close, slow)
        self._onnx_signal = self._params.get("onnx_signal")

    def next(self):
        # ONNX signal override: 1 = long, -1 = short, 0 = hold
        if self._onnx_signal is not None:
            idx = len(self.data.Close) - 1
            sig = (
                self._onnx_signal[idx]
                if hasattr(self._onnx_signal, "__getitem__")
                else self._onnx_signal
            )
            if sig == 1 and not self.position.is_long:
                self.position.close()
                self.buy()
            elif sig == -1 and not self.position.is_short:
                self.position.close()
                self.sell()
            return

        # Fallback: SMA crossover
        if crossover(self._fast_ma, self._slow_ma):
            self.position.close()
            self.buy()
        elif crossover(self._slow_ma, self._fast_ma):
            self.position.close()
            self.sell()


def _build_strategy_class(params: dict[str, Any]):
    """Dynamically create a backtesting.py Strategy subclass with injected params."""
    return type(
        "DynamicStrategy",
        (Strategy, _AIDecisionTreeStrategy),
        {"_params": params},
    )


# ---------------------------------------------------------------------------
# Public BacktestEngine
# ---------------------------------------------------------------------------

class BacktestEngine:
    """Thin wrapper around ``backtesting.Backtest`` that accepts a params dict.

    Args:
        df: OHLCV DataFrame (Open/High/Low/Close/Volume columns, datetime index).
        strategy_params: Dict of parameters to pass to the strategy (e.g.
            ``fast_period``, ``slow_period``, ``onnx_signal``).
        cash: Starting capital in account currency.
        commission: Fractional commission per trade (e.g. 0.002 = 0.2 %).
    """

    def __init__(
        self,
        df: pd.DataFrame,
        strategy_params: dict[str, Any] | None = None,
        cash: float = 10_000.0,
        commission: float = 0.002,
    ) -> None:
        self._df = df.copy()
        self._params = strategy_params or {}
        self._cash = cash
        self._commission = commission

    def run(self) -> dict[str, Any]:
        """Execute the backtest and return a statistics dictionary.

        Returns:
            Dict with keys such as ``Return [%]``, ``Sharpe Ratio``,
            ``Max. Drawdown [%]``, ``# Trades``, etc.  When the
            ``backtesting`` library is not installed a minimal dummy dict
            is returned so callers don't need to branch.
        """
        if not _BT_AVAILABLE:
            logger.warning("backtesting library unavailable — returning dummy stats.")
            return self._dummy_stats()

        # Ensure the DataFrame meets backtesting's requirements
        df = self._prepare_df()
        if df is None or len(df) < 30:
            logger.warning("Not enough data for backtesting (need ≥ 30 rows).")
            return self._dummy_stats()

        strategy_cls = _build_strategy_class(self._params)
        try:
            bt = Backtest(
                df,
                strategy_cls,
                cash=self._cash,
                commission=self._commission,
                exclusive_orders=True,
            )
            stats = bt.run()
            return dict(stats)
        except Exception as exc:
            logger.error("Backtest run failed: %s", exc)
            return self._dummy_stats()

    # ------------------------------------------------------------------
    # Private helpers
    # ------------------------------------------------------------------

    def _prepare_df(self) -> pd.DataFrame | None:
        """Return a DataFrame suitable for backtesting.py (OHLCV, datetime index)."""
        df = self._df.copy()
        required = ["Open", "High", "Low", "Close"]
        missing = [c for c in required if c not in df.columns]
        if missing:
            logger.error("DataFrame missing columns: %s", missing)
            return None
        if "Volume" not in df.columns:
            df["Volume"] = 0
        # backtesting.py needs a proper DatetimeIndex
        if not isinstance(df.index, pd.DatetimeIndex):
            try:
                df.index = pd.to_datetime(df.index)
            except Exception:
                df.index = pd.date_range("2000-01-01", periods=len(df), freq="h")
        df = df[["Open", "High", "Low", "Close", "Volume"]].dropna()
        return df

    @staticmethod
    def _dummy_stats() -> dict[str, Any]:
        return {
            "Return [%]": 0.0,
            "Sharpe Ratio": 0.0,
            "Max. Drawdown [%]": 0.0,
            "# Trades": 0,
            "Win Rate [%]": 0.0,
        }
